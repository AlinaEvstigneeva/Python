# ТЕОРИЯ

# d = {
#     'moskva' : 495,
#     'piter' : 812,          #первый вариант создания словаря
#     'penza' : 8412
# }
# print(d)

# r = dict(moskva = 495, piter = 812, penza = 8412)   # второй вариан создания словаря. ВАЖНО! ключ должен быть str
# print(r)

# a = [['moskva', 495], ['piter', 812], ['penza', 8412]]  #третий способ создания словаря из списка
# t = dict(a)                                             # заводим новую переменную и превращаем список в словарь с помощью dict
# print(t)

# q = dict.fromkeys(['a', 'b', 'c'])  # с помощью функции .fromkeys можно передать ключи и это тоже создаст новый словарь
# print(q)                            # но в значении будет: None, тк мы не передали значения

# q = dict.fromkeys(['a', 'b', 'c'], 100)     # тут мы уже передали значение для каждого ключа, оно равно 100
# print(q)                                    # этот метод используется, когда необходимо проинициализировать ключи 
                                              #  ОПРЕДЕЛЕННЫМ значением

# v = {}      # создание пустого словаря
# v = dict()      # второй вариант создания пустого словаря с помощью йункции dict()

# key - мб str и int (т.е. ключом не может быть изменяемый тип объекта); value - мб любым типом данных 

# К значениям словаря можно обращаться (но не по индексу(i), а по ключу (key)):
# r = dict(moskva = 495, piter = 812, penza = 8412)
# print(r)
# print(r['moskva'])

# Чтобы добавить ключ и его значение, достаточно завести новый ключь и присвоить ему это значение:
# d = { 1: 'one', 2: 'two', 3: 'three'}
# print(d)
# d[4] = 'four'   # Добавляем новый ключ, которого еще нет и присваиваем ему значение. В терминале видим новую пару
# d[5] = 'five'
# print(d)

# Также мы можем любому ключу присваивать новое значение:
# d = { 1: 'one', 2: 'two', 3: 'three'}
# print(d)
# d[1] = 'один'
# d[2] = 'два'
# print(d)


# Делаем из строки s словарь person:
# person = {}     # создаем пустой словарь person
# s = "IVANOV IVAN Samara SGU 5 4 5 3 5 5 4 5"    # наша строка s
# s = s.split()   # с помощью фукнции .split() разбиваем ее на отдельные значения по пробелам (тк у нас между словами пробелы)
# print(s)    # получаем список из отдельных значений, разделенных запятыми
# person['lastName'] = s[0]   # в словарь person в первый ключ lastName мы добавли первое значение из списка s (под индеском [0])
# person['firstName'] = s[1]  # и так далее...
# person['city'] = s[2]
# person['university'] = s[3]

# person['marks'] = []  # с оценками сложнее, тк каждая из них ститается отдельной сторокой. Поэтому мы заводим новый пустой словарь
# for i in s[4:]:     # циклом for пробегаемся по строке s, начиная с 4го значения и до конца ([4:])
#     person['marks'].append(int(i))  # в новый словарь добавляем оценки с помощью функции .append(),
# print(person)                       # переводя строчные значения (тк s - это str) в интовые (int(i))
# Таким образом все цифрфы, указанные в строке стали значением ключа 'marks' в виде списка


# Удаление ключа и значения из словаря с помощью фукции del:
# d = { 1: 'one', 2: 'two', 3: 'three'}
# print(d)
# del d[1]
# print(d)

# Определенеи длины словаря с помощью функции len()
# d = { 1: 'one', 2: 'two', 3: 'three'}
# print(d)
# print(len(d))    # данная функция подсчитывает кол-во пар ключ-значение

# также мы можем проверить наличие определенных ключей в нашем словаре
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(1 in d, 5 in d, 7 in d, 8 not in d)


# Если мы обращаемся к ключу, которого нет в нашем словаре, то мы получим ошибку.
# чтобы этого избежать, надо сначала пробежаться по этому словарю и проверить есть ли вообще такой ключ
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(len(d))       # проверяем длину словаря
# if 7 in d:          # бежим по словарю с помощью if и ищем ключ [7], если он есть
#     print(d[7])     # выводим на печать его значение
# else:
#     d[7] = 'seven'  # иначе: добавляем в наш вловарь этот ключ [7] и присваиваем ему значение 'seven'
# print(d)            # в таком случае никаких ошибок не будет 


# Тк Словарь это коллекция элементов, мы можем пробегать по нему цкилом for
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# for i in d:     # i в данном случае будет ключом
#     print(i)

# for i in d:
#     print(i, d[i])   # а так мы выведем на печать и ключ и значение




# Методы для словарей

    # .clear() - метод очищения всего словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# d.clear()
# print(d)

    # .get() - метод принимает в скобках ключ и выдает его значение
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.get(4))
# print(d.get(6, 'No such key')) # также можно ввести второй аргумент который будет выводится, если ключ не найден

    # .setdefault() - метод также принимает ключ и выдает его значение. Но если ключа нет, то он его создаст сам со значением None
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.setdefault(6))    # также можно использовать без print(), значение не выведется, а новая пара добавится в словарь
# print(d)

# d.setdefault(6, 'six')  # но мы можем через запятую передать значение, которое хотим присвоить новому ключу
# print(d)

    # .pop() - метод, который принимает ключ и выводит его значение , но при этом удаляет эту пару из словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.pop(3)) # также может использоваться без print(), но значение не выведется, а просто удалится пара из словаря
# print(d)        # метод .pop() без параметра (без ключа в скобках) не работает

    # .popitem() - в отличие от .pop(), он не принимает никакие параметры и удаляет случайные значения (пары) из словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.popitem())
# print(d)

    # .keys() - позволяет получить все ключи нашего словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.keys())

    # .values() - позволяет вернуть все значения словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.values())

    # .items() - позволяет вернуть пары (ключ-значение) словаря
# d = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}
# print(d)
# print(d.items())





# СИТУАЦИИ, КОГДА НАМ НУЖНЫ СЛОВАРИ

    # 1. ПОДСЧЕТ КОЛИЧЕСТВА ОБЪЕКТОВ - при таком использовании в словаре ключи будут являться объектами,
        # а значение ключа - количество появления этих объектов.


# Дана строка на вход, необходимо посчитать сколько раз встретилась в этой строке каждая буква буква.
# s = input()     # создаем строку, которую будет вводить пользователь
# d = {}      # создаем пустой словарь, в котором и будудт считаться наши буквы

# for i in s:
#     if i in d:
#         d[i] +=1      # ПЕРВЫЙ вариант
#     else:
#         d[i] = 1
# print(d)


# s = input()
# d = {}
# for i in s:
#     if i in d:
#         d[i] +=1        # ВТОРОЙ вариант
#     else:
#         d[i] = 1
# for i in d:         # можно распечатать словарь с помощью цикла for
#     print(i, d[i])


# s = input()
# d = {}
# for i in s:
#     if i in d:
#         d[i] +=1        # ТРЕТИЙ вариант
#     else:
#         d[i] = 1
# for i in sorted(d):         # встроенная функция sorted() упорядочивает ключи в алфавитном порядке
#     print(i, d[i])


# наша программа подсчитывает не только буквы, но и служебные символы и цифры, а тк задание было про буквы, добавляем следующее
# s = input()
# d = {}
# for i in s:
#     if i.isalpha():     # добавляем проверку на буквы с помощью метода .isalpha()
#         if i in d:
#             d[i] +=1        # ЧЕТВЕРТЫЙ вариант
#         else:
#             d[i] = 1
# for i in sorted(d):
#     print(i, d[i])


# s = input()
# d = {}
# for i in s:
#     if i.isalpha():                 # ШЕСТОЙ вариант
#         d[i] = d.get(i, 0) + 1      # можем заменить цикл if на одну строчку с методом .get()
# for i in sorted(d):
#     print(i, d[i])



    # 2.ЗАМЕНА РАЗРЯЖЕННОГО СПИСКА
        # Вместо списка(массива) из большого количства элементов, в котором предполагается, 
        # что не все элементы будут использоваться.


    # 3.УСТАНОВИТЬ СООТВЕТСТВИЕ МЕЖДУ ОБЪЕКТАМИ
        
# Необходимо создать программу - англо-русский словарь. Где программа будет искать соответствия междку анг и рус словами.
# words = {}  #заводим пустой словарь
# while True:     # запускаем бесконечный цикл
#     s = input("Введите слово: ")
#     if s in words:
#         print("Слово",s,'переводится как',words[s])
#     else:
#         print("Введите перевод слова",s)
#         words[s] = input()


    # 4.ХРАНЕНИЕ ДАННЫХ ОБ ОБЪЕКТЕ




# МНОЖЕСТВА - неупорядоченная коллекция без дублей. Может сосотоять только из неизменяемых типов

# Создание множества
# a = {1,2,3,4,5}         # первый вариант
# print(a)

# c = set('asdfghjkkjhgfdsa')     # второй вариант
# print(c)

# d = set([1,2,3,4,5,6])      # создание множества из списка
# print(d)

# e = set(range(5))       # создание множества м помощью range
# print(e)

# f = set()           # создание пустого множества
# print(f, type(f))


# Удаление дублей из списка с помощью множества
# a = [1,2,3,4,5,6,7,2,3,4,5,5,6,6,3,2,]      # дан список с дублирующимися элементами
# a = list(set(a))        # сначала мы из списка делаем множество set(a) - оно автоматически удалит дубли.
# print(a)                # затем снова превращаете множ в список list(set(a)) и присваиваете его значения переменной а


# Добавление элемента

    # .add() - функция добавления элемента
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.add(9)
# print(a)

    # .update() - принимает итерабельные последовательности (списки, строки, range, само множество)
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.update([5, 7, 12])
# print(a)


# Удаленеи элементов

    # .discard() - функция удаления элемента, если мы попытаемся удалить эл-т, которого уже нет - ошибки не будет
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.discard(34)
# print(a)

    # .remove() - уд-е элемента, но если попробуем удалить эл-т, которого уже нет - выскочит ошибка
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.remove(34)
# print(a)

    # .pop() - удаляет любой рандомный элемент
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.pop()
# print(a)

    # .clear() - метод, очищающий множество целиком
# a = {1 , 34, 453, 45, 6, 75, 8}
# a.clear()
# print(a)


# Операции над множествами
# Основные операции над множествами такие же как и у списков, но есть дополнительные:

    # Поиск пересечений в множествах ( с помощью & )
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# c = {10,12,11}
# print(a & b)

    # .intersection() - так же позволяет найти пересечение множест, при этом никак не меняет сами множества
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# c = {10,12,11}
# print(a.intersection(b))

    # .intersection_update() - тоже ищет пересечения, но можно поменять список
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# c = {10,12,11}
# a.intersection_update(b)
# print(a, b)     # можем увидеть что список а стал равено пересечению списков а и b, а список b не изменился


    # Объединение множеств с помощью ( | )
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# print(a | b)

    # .union() - метод для объелинения множеств
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# a = a.union(b)      # обязательно нужна переменная для нового множества или приствоить одному из старых
# print(a)

    # Вычетание из множеств (a - b) - вычитаются све элементы пересечения
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# print(a - b)

    # Симметричная разность (a ^ b) - объединяются элементы множеств, кроме тех, которые повторяются в обоих
# a = {4,3,2,1}
# b = {3,4,5,6,7}
# print(a ^ b)








# Напишите программу, которая принимает на вход строку, и отслеживает, 
# сколько раз каждый символ уже встречался. 
# Количество повторов добавляется к символам с помощью постфикса формата _n.
# Input: a a a b c a a d c d d
# Output: a a_1 a_2 b c a_3 a_4 d c_1 d_1 d_2
# Для решения данной задачи используйте функцию
# .split()

# str_1 = input('Введите строку, прописыпая каждый знак через пробел: ').split()
# print(str_1)
# count = 0

# for i in range(len(str_1)):
#     for j in range(i + 1,len(str_1)):                     # первый вариант решения
#         if str_1[i] == str_1[j]:
#             count += 1
#             str_1[j] += '_' + str(count)
#     count = 0 
# print(str_1)



# string = input("Enter a string: ")

# unique_chars = dict()
# output_string = ""

# char_list = string.split()

# for char in char_list:                                        # второй вариант решения
# if char in unique_chars:
# unique_chars[char] += 1
# output_string += f"{char}_{unique_chars[char]} "
# else:
# unique_chars[char] = 0
# output_string += char + " "

# print(output_string)









# Задача №27. Решение в группах
# Пользователь вводит текст(строка). Словом считается
# последовательность непробельных символов идущих
# подряд, слова разделены одним или большим числом
# пробелов. Определите, сколько различных слов
# содержится в этом тексте.
# Input: She sells sea shells on the sea shore The shells
# that she sells are sea shells I'm sure So if she sells sea
# shells on the sea shore I'm sure that the shells are sea
# shore shells
# Output: 13

# s = input("Введите строку: ")
# result = set(s.lower().split())        # мой вариант решения
# print(len(result))


# print(len(set(input("Введите текст: ").lower().split())))       # более короткий вариант решения







# Задача №29. Решение в группах
# Ваня и Петя поспорили, кто быстрее решит
# следующую задачу: “Задана последовательность
# неотрицательных целых чисел. Требуется определить
# значение наибольшего элемента
# последовательности, которая завершается первым
# встретившимся нулем (число 0 не входит в
# последовательность)”. Однако 2 друга оказались не
# такими смышлеными. Никто из ребят не смог до
# конца сделать это задание. Они решили так: у кого
# будет меньше ошибок в коде, тот и выиграл спор. За
# помощью товарищи обратились к Вам, студентам.
# Примечание: Программные коды на следующих
# слайдах


n = int(input("Введите число: "))
max_n = n

while n != 0:
    n = int(input("Введите следующее число: "))
    if max_n < n:
        max_n = n
print(max_n)